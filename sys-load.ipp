// NB: This is a *.IPP file because the Arduino IDE cannot handle *.INC files

ParseLine("-ML- !           8 3 -MLX- inline");
ParseLine("-ML- @          10 3 -MLX- inline");
ParseLine(": \\ 0 >in @ ! ; immediate");
ParseLine("\\ ***********************************************");
ParseLine("\\ c3 opcodes");
ParseLine("\\ ***********************************************");
ParseLine("\\ (stop)      is 0");
ParseLine("\\ (lit1)      is 1");
ParseLine(": (lit4)         2 ;       inline");
ParseLine("-ML- EXIT        3 3 -MLX- inline");
ParseLine(": (exit)         3 ;       \\ NOT inline");
ParseLine(": (call)         4 ;       inline");
ParseLine(": (jmp)          5 ;       inline");
ParseLine(": (jmpz)         6 ;       inline");
ParseLine(": (jmpnz)        7 ;       inline");
ParseLine("\\ !   (line 1)   8         \\ defined above");
ParseLine("-ML- c!          9 3 -MLX- inline");
ParseLine("\\ @   (line 2)  10         \\ defined above");
ParseLine("-ML- c@         11 3 -MLX- inline");
ParseLine(": (dup)         12 ;       inline");
ParseLine("-ML- DUP        12 3 -MLX- inline");
ParseLine("-ML- SWAP       13 3 -MLX- inline");
ParseLine("-ML- OVER       14 3 -MLX- inline");
ParseLine("-ML- DROP       15 3 -MLX- inline");
ParseLine("-ML- +          16 3 -MLX- inline");
ParseLine("-ML- *          17 3 -MLX- inline");
ParseLine("-ML- /MOD       18 3 -MLX- inline");
ParseLine("-ML- -          19 3 -MLX- inline");
ParseLine("-ML- 1+         20 3 -MLX- inline");
ParseLine("-ML- 1-         21 3 -MLX- inline");
ParseLine("-ML- <          22 3 -MLX- inline");
ParseLine("-ML- =          23 3 -MLX- inline");
ParseLine("-ML- >          24 3 -MLX- inline");
ParseLine("-ML- 0=         25 3 -MLX- inline");
ParseLine("-ML- >R         26 3 -MLX- inline");
ParseLine("-ML- R@         27 3 -MLX- inline");
ParseLine("-ML- R>         28 3 -MLX- inline");
ParseLine("-ML- DO         29 3 -MLX- inline");
ParseLine("-ML- LOOP       30 3 -MLX- inline");
ParseLine("-ML- -LOOP      31 3 -MLX- inline");
ParseLine("-ML- (I)        32 3 -MLX- inline");
ParseLine("-ML- COM        33 3 -MLX- inline");
ParseLine("-ML- AND        34 3 -MLX- inline");
ParseLine("-ML- OR         35 3 -MLX- inline");
ParseLine("-ML- XOR        36 3 -MLX- inline");
ParseLine("-ML- EMIT       37 3 -MLX- inline");
ParseLine("-ML- TIMER      38 3 -MLX- inline");
ParseLine("-ML- KEY        39 3 -MLX- inline");
ParseLine("-ML- ?KEY       40 3 -MLX- inline");
ParseLine(": (TYPE)        41 ;       inline");
ParseLine("-ML- TYPE       41 3 -MLX- inline");
ParseLine("-ML- TYPEZ      42 3 -MLX- inline");
ParseLine("\\ (define)   is 43         \\ defined in c3");
ParseLine("\\ (end-word) is 44         \\ defined in c3");
ParseLine("-ML- CREATE     45 3 -MLX- inline");
ParseLine("-ML- '          46 3 -MLX- inline");
ParseLine("-ML- NEXT-WORD  47 3 -MLX- inline");
ParseLine("\\ (iX)       is 48         \\ defined in c3");
ParseLine("\\ (dX)       is 49         \\ defined in c3");
ParseLine("\\ (rX)       is 50         \\ defined in c3");
ParseLine("\\ (rX-)      is 51         \\ defined in c3");
ParseLine("\\ (rX+)      is 52         \\ defined in c3");
ParseLine("\\ (sX)       is 53         \\ defined in c3");
ParseLine("-ML- +REGs      54 3 -MLX- inline");
ParseLine("-ML- -REGS      55 3 -MLX- inline");
ParseLine("\\ : INLINE      56 ;       \\ defined in c3");
ParseLine("\\ : IMMEDIATE   57 ;       \\ defined in c3");
ParseLine("\\ Words for the PC version");
ParseLine("-ML- SYSTEM     58 3 -MLX- inline");
ParseLine("-ML- FOPEN      59 3 -MLX- inline");
ParseLine("-ML- FCLOSE     60 3 -MLX- inline");
ParseLine("-ML- FREAD      61 3 -MLX- inline");
ParseLine("-ML- FWRITE     62 3 -MLX- inline");
ParseLine("-ML- (load)     63 3 -MLX- inline");
ParseLine("\\ ***********************************************");
ParseLine("\\ OK ... now we can get things going");
ParseLine("\\ ***********************************************");
ParseLine(": [ 0 state ! ; immediate");
ParseLine(": ] 1 state ! ;");
ParseLine(": last (last) @ ;");
ParseLine(": here (here) @ ;");
ParseLine(": c, here c! here 1+     (here) ! ;");
ParseLine(": ,  here !  here cell + (here) ! ;");
ParseLine(": mem-end   mem  mem-sz  + ;");
ParseLine(": vars-end  vars vars-sz + ;");
ParseLine(": ++ dup @ 1+ swap ! ; inline");
ParseLine(": -- dup @ 1- swap ! ; inline");
ParseLine(": vhere  (vhere) @ ;");
ParseLine(": allot  vhere + (vhere) ! ;");
ParseLine(": vc, vhere c! (vhere) ++ ;");
ParseLine(": v,  vhere ! cell allot ;");
ParseLine(": bye 999 state ! ;");
ParseLine(": cells cell * ; inline");
ParseLine(": constant  create (lit4) c, , (exit) c, ;");
ParseLine(": variable  vhere constant cell allot ;");
ParseLine(": val  vhere constant ;");
ParseLine(": (val)  here 1- cell - constant ;");
ParseLine(": :noname  here 1 state ! ;");
ParseLine(": does>  r> last ! ;");
ParseLine(": exec  >r ;");
ParseLine(": if    (jmpz) c, here 0 , ; immediate");
ParseLine(": else  (jmp) c, here swap 0 , here swap ! ; immediate");
ParseLine(": then  here swap ! ; immediate");
ParseLine(": exit  (exit) c,   ; immediate");
ParseLine(": begin  here         ; immediate");
ParseLine(": until  (jmpz) c, , ; immediate");
ParseLine(": again  (jmp) c, , ; immediate");
ParseLine(": while  (jmpz) c, here 0 , ; immediate");
ParseLine(": repeat swap (jmp) c, , here swap ! ; immediate");
ParseLine(": for 0 swap do ; inline");
ParseLine(": next -loop ; inline");
ParseLine("\\ Some 'MachineForth' inspired words");
ParseLine(": -if     (dup) c,  (jmpz) c, here 0 , ; immediate");
ParseLine(": -until  (dup) c,  (jmpz) c, , ; immediate");
ParseLine(": -while  (jmpnz) c, , ; immediate");
ParseLine(": tuck  swap over ; inline");
ParseLine(": nip   swap drop ; inline");
ParseLine(": 2dup  over over ; inline");
ParseLine(": 2drop drop drop ; inline");
ParseLine(": ?dup  dup if dup then ;");
ParseLine(": /   /mod nip  ; inline");
ParseLine(": mod /mod drop ; inline");
ParseLine(": +! swap over @ + swap ! ;  inline");
ParseLine(": c++ dup c@ 1+ swap c! ; inline");
ParseLine(": 2*  dup + ; inline");
ParseLine(": 2/  2 / ; inline");
ParseLine(": 2+  1+ 1+ ; inline");
ParseLine(": <=  > 0= ; inline");
ParseLine(": >=  < 0= ; inline");
ParseLine(": <>  = 0= ; inline");
ParseLine(": rdrop r> drop ; inline");
ParseLine(": rot   >r swap r> swap ;");
ParseLine(": -rot  swap >r swap r> ;");
ParseLine(": ( begin ");
ParseLine("        >in @ c@ dup 0= if drop exit then");
ParseLine("        >in ++ ')' = if exit then");
ParseLine("    again ; immediate");
ParseLine(": bl  #32 ; inline");
ParseLine(": tab  #9 emit ; inline");
ParseLine(": cr  #13 emit #10 emit ; inline");
ParseLine(": space bl emit ; inline");
ParseLine(": negate  com 1+ ; inline");
ParseLine(": abs  dup 0 < if negate then ;");
ParseLine(": min  over over > if swap then drop ;");
ParseLine(": max  over over < if swap then drop ;");
ParseLine(": btw +regs s3 s2 s1 r1 r2 >= r1 r3 <= and -regs ;");
ParseLine(": i  (i) @ ;");
ParseLine(": j  (i) 3 cells - @ ;");
ParseLine(": +i (i) +! ;");
ParseLine(": unloop (lsp) @ 3 - 0 max (lsp) ! ;");
ParseLine("variable (neg)");
ParseLine("variable #bufp");
ParseLine(": hold #bufp -- #bufp @ c! ;          \\ ( c -- )");
ParseLine(": #digit dup 9 > if 7 + then '0' + ;  \\ ( n -- c )");
ParseLine(": >neg dup 0 < (neg) ! abs ;          \\ ( n1 -- u1 )");
ParseLine(": <# here #66 + #bufp ! 0 hold >neg ; \\ ( n1 -- u1 )");
ParseLine(": # base @ /mod swap #digit hold ;    \\ ( u1 -- u2 )");
ParseLine(": #S begin # dup 0= until drop ;      \\ ( u1 -- )");
ParseLine(": #> (neg) @ if '-' hold then ;       \\ ( -- )");
ParseLine(": #P #bufp @ typez ;                  \\ ( -- )");
ParseLine(": (.) <# #S #> #P ;");
ParseLine(": . (.) space ;");
ParseLine(": 0sp 0 (sp) ! ;");
ParseLine(": depth (sp) @ 1- ;");
ParseLine(": .s '(' emit space depth ?dup if");
ParseLine("        0 do (stk) i 1+ cells + @ . loop ");
ParseLine("    then ')' emit ;");
ParseLine(": count ( str--a n ) dup 1+ swap c@ ; inline");
ParseLine(": dump ( a n-- ) for dup c@ . 1+ next drop ;");
ParseLine(": T2 ( --str end )   +regs   >in ++");
ParseLine("    vhere dup s8 s9  0 r8+ c!");
ParseLine("    begin >in @ c@ s1");
ParseLine("        r1 if >in ++ then");
ParseLine("        r1 0= r1 '\"' = or");
ParseLine("        if 0 r8+ c!   r9 r8 -regs   exit then");
ParseLine("        r1   r8+ c!   r9 c++");
ParseLine("    again ;");
ParseLine(": s\" ( --str ) T2 state @ 0= if drop exit then (vhere) ! (lit4) c, , ; immediate");
ParseLine(": .\" ( -- ) T2 state @ 0= if drop count type exit then");
ParseLine("    (vhere) ! (lit4) c, ,");
ParseLine("    (call) c, [ (lit4) c, ' count drop drop , ] ,");
ParseLine("    (type) c, ;  immediate");
ParseLine(": .word cell + 1+ count type ;");
ParseLine(": words +regs 0 s1 0 s3 last s2 begin");
ParseLine("        r2 mem-end < while");
ParseLine("            r1+ #10 > if 0 s1 cr then");
ParseLine("            i3 r2 .word tab r2 word-sz + s2");
ParseLine("    repeat");
ParseLine("    .\" (\" r3 . .\" words)\" -regs ;");
ParseLine(": binary  %10 base ! ;");
ParseLine(": decimal #10 base ! ;");
ParseLine(": hex     $10 base ! ;");
ParseLine(": ? @ . ;");
ParseLine(": lshift ( n1 s--n2 ) 0 do 2* loop ;");
ParseLine(": rshift ( n1 s--n2 ) 0 do 2/ loop ;");
ParseLine(": load next-word drop 1- (load) ;");
ParseLine(": load-abort #99 state ! ;");
ParseLine(": loaded? if 2drop load-abort then ;");
ParseLine("variable (fg) 2 cells allot");
ParseLine(": fg cells (fg) + ;");
ParseLine(": marker here 0 fg ! vhere 1 fg ! last 2 fg ! ;");
ParseLine(": forget 0 fg @ (here) ! 1 fg @ (vhere) ! 2 fg @ (last) ! ;");
ParseLine(": forget-1 last @ (here) ! last word-sz + (last) ! ;");
ParseLine("marker");
ParseLine(": .ver version 100 /mod (.) '.' emit . ;");
ParseLine(".\" c3 - v\" .ver .\" - Chris Curl\" cr");
ParseLine("here mem -   . .\" code bytes used, \" last here - . .\" bytes free.\" cr");
ParseLine("vhere vars - . .\" variable bytes used, \" vars-end vhere - . .\" bytes free.\"");
ParseLine("forget");
ParseLine(": benches forget s\" benches.c3\" dup count type (load) ;");
ParseLine(": sb forget s\" sandbox.c3\" (load) ;");
ParseLine(": work forget s\" work.c3\" (load) ;");
ParseLine(": ed forget s\" editor.c3\" (load) ;");
ParseLine("marker");
