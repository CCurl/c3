void sysLoad() {
    char *m1i = "-ML- %s %d 3 -MLX- INLINE";
    char *m2n = "-ML- %s %d %d 3 -MLX-";
    char *m2i = "-ML- %s %d %d 3 -MLX- INLINE";
    char *lit = ": %s %d ; INLINE";

    parseF(m2n, "INLINE", SYS_OPS, INLINE); last->f = IS_INLINE;
    parseF(m2i, "IMMEDIATE", SYS_OPS, IMMEDIATE);
    parseF(m2i, ":", SYS_OPS, DEFINE);
    parseF(m2n, ";", SYS_OPS, ENDWORD); last->f = IS_IMMEDIATE;

    parseF(lit, "(LIT4)", LIT4);
    parseF(m1i, "EXIT", EXIT);
    parseF(lit, "(EXIT)", EXIT); last->f = 0;
    parseF(lit, "(CALL)", CALL);
    parseF(lit, "(JMP)", JMP);
    parseF(lit, "(JMPZ)", JMPZ);
    parseF(lit, "(JMPNZ)", JMPNZ);
    parseF(m1i, "!", STORE);
    parseF(m1i, "C!", CSTORE);
    parseF(m1i, "@", FETCH);
    parseF(m1i, "C@", CFETCH);
    parseF(m1i, "DUP", DUP);
    parseF(lit, "(DUP)", DUP);
    parseF(m1i, "SWAP", SWAP);
    parseF(m1i, "OVER", OVER);
    parseF(m1i, "DROP", DROP);
    parseF(m1i, "+", ADD);
    parseF(m1i, "*", MULT);
    parseF(m1i, "/MOD", SLMOD);
    parseF(m1i, "-", SUB);
    parseF(m1i, "1+", INC);
    parseF(m1i, "1-", DEC);
    parseF(m1i, "<", LT);
    parseF(m1i, "=", EQ);
    parseF(m1i, ">", GT);
    parseF(m1i, "0=", NOT);
    parseF(m1i, "NOT", NOT);
    parseF(m1i, ">R", RTO);
    parseF(m1i, "R@", RFETCH);
    parseF(m1i, "R>", RFROM);
    parseF(m1i, "DO", DO);
    parseF(m1i, "LOOP", LOOP);
    parseF(m1i, "-LOOP", LOOP2);
    parseF(m1i, "(I)", INDEX);
    parseF(m1i, "COM", COM);
    parseF(m1i, "AND", AND);
    parseF(m1i, "OR", OR);
    parseF(m1i, "XOR", XOR);
    parseF(m1i, "TYPE", TYPE);
    parseF(lit, "(TYPE)", TYPE);
    parseF(m1i, "STR_OPS", STR_OPS);
    // rX, sX, iX, dX, iX+, dX+ are hard-coded in c3.c
    parseF(m1i, "+REGS", REG_NEW);
    parseF(m1i, "-REGS", REG_FREE);
    parseF(m1i, "FLT_OPS", FLT_OPS);
    parseF(m1i, "SYS_OPS", SYS_OPS);

    parseF(m2i, "(.)",       SYS_OPS, DOT);
    parseF(m2i, "ITOA",      SYS_OPS, ITOA);
    parseF(m2i, "CREATE",    SYS_OPS, CREATE);
    parseF(m2i, "'",         SYS_OPS, FIND);
    parseF(m2i, "NEXT-WORD", SYS_OPS, WORD);
    parseF(m2i, "TIMER",     SYS_OPS, TIMER);
    parseF(m2i, ",",         SYS_OPS, COMMA);
    parseF(m2i, "C,",        SYS_OPS, CCOMMA);
    parseF(m2i, "KEY",       SYS_OPS, KEY);
    parseF(m2i, "?KEY",      SYS_OPS, QKEY);
    parseF(m2i, "EMIT",      SYS_OPS, EMIT);
    parseF(m2i, "TYPEZ",     SYS_OPS, TYPEZ);

    parseF(m2i, "S-TRUNC",   STR_OPS, TRUNC);
    parseF(m2i, "S-CPY",     STR_OPS, STRCPY);
    parseF(m2i, "S-CAT",     STR_OPS, STRCAT);
    parseF(m2i, "S-LEN",     STR_OPS, STRLEN);
    parseF(m2i, "S-EQ",      STR_OPS, STREQ);
    parseF(m2i, "S-EQ-I",    STR_OPS, STREQI);

    parseF(m2i, "F+",  FLT_OPS, FADD);
    parseF(m2i, "F-",  FLT_OPS, FSUB);
    parseF(m2i, "F*",  FLT_OPS, FMUL);
    parseF(m2i, "F/",  FLT_OPS, FDIV);
    parseF(m2i, "F.",  FLT_OPS, FDOT);
    parseF(m2i, "F=",  FLT_OPS, FEQ);
    parseF(m2i, "F<",  FLT_OPS, FLT);
    parseF(m2i, "F>",  FLT_OPS, FGT);
    parseF(m2i, "F2I", FLT_OPS, F2I);
    parseF(m2i, "I2F", FLT_OPS, I2F);

    loadStartupWords();

    parseF(": VERSION %ld ;", VERSION);
    parseF(": (sp) $%lx ;", &DSP);
    parseF(": (rsp) $%lx ;", &RSP);
    parseF(": (lsp) $%lx ;", &lsp);
    parseF(": (here) $%lx ;", &here);
    parseF(": (vhere) $%lx ;", &vhere);
    parseF(": (last) $%lx ;", &last);
    parseF(": (stk) $%lx ;", &ds.stk[0].i);
    parseF(": (rstk) $%lx ;", &rs.stk[0].c);
    parseF(": tib $%lx ;", &tib[0]);
    parseF(": >in $%lx ;", &in);
    parseF(": mem $%lx ;", &mem[0]);
    parseF(": mem-sz %ld ;", MEM_SZ);
    parseF(": vars $%lx ;", &vars[0]);
    parseF(": vars-sz %ld ;", VARS_SZ);
    parseF(": regs $%lx ;", &reg[0]);
    parseF(": (output_fp) $%lx ;", &output_fp);
    parseF(": (input_fp) $%lx ;", &input_fp);
    parseF(": state $%lx ;", &state);
    parseF(": word-sz %ld ;", sizeof(dict_t));
    parseF(": base $%lx ;", &base);
    parseF(": bye %d state ! ;", ALL_DONE);
    parseF(": CELL %d ; inline", CELL_SZ);

    ParseLine(": \\ 0 >in @ ! ; immediate");
    ParseLine(": [ 0 state ! ; immediate");
    ParseLine(": ] 1 state ! ;");
    ParseLine(": last (last) @ ;");
    ParseLine(": here (here) @ ;");
    ParseLine(": mem-end   mem  mem-sz  + ;");
    ParseLine(": vars-end  vars vars-sz + ;");
    ParseLine(": ++ dup @ 1+ swap ! ; inline");
    ParseLine(": -- dup @ 1- swap ! ; inline");
    ParseLine(": vhere  (vhere) @ ;");
    ParseLine(": allot  vhere + (vhere) ! ;");
    ParseLine(": vc, vhere c! (vhere) ++ ;");
    ParseLine(": v,  vhere ! cell allot ;");
    ParseLine(": cells cell * ; inline");
    ParseLine(": constant  create (lit4) c, , (exit) c, ;");
    ParseLine(": variable  vhere constant cell allot ;");
    ParseLine(": val  vhere constant ;");
    ParseLine(": (val)  here 1- cell - constant ;");
    ParseLine(": :noname  here 1 state ! ;");
    ParseLine(": does>  r> last ! ;");
    ParseLine(": exec  >r ;");
    ParseLine(": if    (jmpz) c, here 0 , ; immediate");
    ParseLine(": else  (jmp) c, here swap 0 , here swap ! ; immediate");
    ParseLine(": then  here swap ! ; immediate");
    ParseLine(": exit  (exit) c,   ; immediate");
    ParseLine(": begin  here       ; immediate");
    ParseLine(": until  (jmpz) c, , ; immediate");
    ParseLine(": again  (jmp) c, , ; immediate");
    ParseLine(": while  (jmpz) c, here 0 , ; immediate");
    ParseLine(": repeat swap (jmp) c, , here swap ! ; immediate");
    ParseLine(": for 0 swap do ; inline");
    ParseLine(": next -loop ; inline");
    ParseLine(": -if     (dup) c,  (jmpz) c, here 0 , ; immediate");
    ParseLine(": -until  (dup) c,  (jmpz) c, , ; immediate");
    ParseLine(": -while  (jmpnz) c, , ; immediate");
    ParseLine(": tuck  swap over ; inline");
    ParseLine(": nip   swap drop ; inline");
    ParseLine(": 2dup  over over ; inline");
    ParseLine(": 2drop drop drop ; inline");
    ParseLine(": ?dup  dup if dup then ;");
    ParseLine(": /   /mod nip  ; inline");
    ParseLine(": mod /mod drop ; inline");
    ParseLine(": +! swap over @ + swap ! ;  inline");
    ParseLine(": c++ dup c@ 1+ swap c! ; inline");
    ParseLine(": 2*  dup + ; inline");
    ParseLine(": 2/  2 / ; inline");
    ParseLine(": 2+  1+ 1+ ; inline");
    ParseLine(": <=  > 0= ; inline");
    ParseLine(": >=  < 0= ; inline");
    ParseLine(": <>  = 0= ; inline");
    ParseLine(": rdrop r> drop ; inline");
    ParseLine(": rot   >r swap r> swap ;");
    ParseLine(": -rot  swap >r swap r> ;");
    ParseLine(": ( begin");
    ParseLine(">in @ c@ dup 0= if drop exit then");
    ParseLine(">in ++ ')' = if exit then");
    ParseLine("again ; immediate");
    ParseLine(": bl  #32 ; inline");
    ParseLine(": tab  #9 emit ; inline");
    ParseLine(": cr  #13 emit #10 emit ; inline");
    ParseLine(": space bl emit ; inline");
    ParseLine(": . (.) bl emit ; inline");
    ParseLine(": negate  com 1+ ; inline");
    ParseLine(": abs  dup 0 < if negate then ;");
    ParseLine(": min  over over > if swap then drop ;");
    ParseLine(": max  over over < if swap then drop ;");
    ParseLine(": btw +regs s3 s2 s1 r1 r2 >= r1 r3 <= and -regs ;");
    ParseLine(": i  (i) @ ;");
    ParseLine(": j  (i) 3 cells - @ ;");
    ParseLine(": +i (i) +! ;");
    ParseLine(": unloop (lsp) @ 3 - 0 max (lsp) ! ;");
    ParseLine(": 0sp 0 (sp) ! ;");
    ParseLine(": depth (sp) @ 1- ;");
    ParseLine(": .s '(' emit space depth ?dup if");
    ParseLine("0 do (stk) i 1+ cells + @ . loop");
    ParseLine("then ')' emit ;");
    ParseLine(": count ( str--a n ) dup 1+ swap c@ ; inline");
    ParseLine(": dump ( a n-- ) for dup c@ . 1+ next drop ;");
    ParseLine(": T2 ( --str end )   +regs   >in ++");
    ParseLine("vhere dup s8 s9  0 r8+ c!");
    ParseLine("begin >in @ c@ s1");
    ParseLine("r1 if >in ++ then");
    ParseLine("r1 0= r1 '\"' = or");
    ParseLine("if 0 r8+ c!   r9 r8 -regs   exit then");
    ParseLine("r1   r8+ c!   r9 c++");
    ParseLine("again ;");
    ParseLine(": s\" ( --cstr ) T2 state @ 0= if drop exit then (vhere) ! (lit4) c, , ; immediate");
    ParseLine(": .\" ( -- ) T2 state @ 0= if drop count type exit then");
    ParseLine("(vhere) ! (lit4) c, ,");
    ParseLine("(call) c, [ (lit4) c, ' count drop drop , ] ,");
    ParseLine("(type) c, ;  immediate");
    ParseLine(": T3 ( --zstr end )   +regs   >in ++");
    ParseLine("vhere dup s8 s9");
    ParseLine("begin >in @ c@ s1");
    ParseLine("r1 if >in ++ then");
    ParseLine("r1 0= r1 '\"' = or");
    ParseLine("if 0 r8+ c!   r9 r8 -regs   exit then");
    ParseLine("r1   r8+ c!");
    ParseLine("again ;");
    ParseLine(": z\" ( --zstr ) T3 state @ 0= if drop exit then (vhere) ! (lit4) c, , ; immediate");
    ParseLine(": .word cell + 1+ count type ;");
    ParseLine(": words +regs 0 s1 0 s3 last s2 begin");
    ParseLine("r2 mem-end < while");
    ParseLine("r1+ #10 > if 0 s1 cr then");
    ParseLine("i3 r2 .word tab r2 word-sz + s2");
    ParseLine("repeat");
    ParseLine(".\" (\" r3 . .\" words)\" -regs ;");
    ParseLine(": binary  %10 base ! ;");
    ParseLine(": decimal #10 base ! ;");
    ParseLine(": hex     $10 base ! ;");
    ParseLine(": ? @ . ;");
    ParseLine(": lshift ( n1 s--n2 ) 0 do 2* loop ;");
    ParseLine(": rshift ( n1 s--n2 ) 0 do 2/ loop ;");
    ParseLine(": load next-word drop 1- (load) ;");
    ParseLine(": load-abort #99 state ! ;");
    ParseLine(": loaded? if 2drop load-abort then ;");
    ParseLine("variable T0 2 cells allot");
    ParseLine(": T1 cells T0 + ;");
    ParseLine(": marker here 0 T1 ! vhere 1 T1 ! last 2 T1 ! ;");
    ParseLine(": forget 0 T1 @ (here) ! 1 T1 @ (vhere) ! 2 T1 @ (last) ! ;");
    ParseLine(": forget-1 last @ (here) ! last word-sz + (last) ! ;");
    ParseLine("marker");
}
